!
!     MAGNHOPF -- MAGNETIC HOPFIONS LIBRARY AND A SET OF TOOLS
!
!     (c) 2023 Konstantin L. Metlov <metlov@donfti.ru>
!
!     This program is free software: you can redistribute it and/or modify
!     it under the terms of the GNU General Public License as published by
!     the Free Software Foundation, either version 3 of the License, or
!     (at your option) any later version.
!
!     This program is distributed in the hope that it will be useful,
!     but WITHOUT ANY WARRANTY; without even the implied warranty of
!     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!     GNU General Public License for more details.
!
!     You should have received a copy of the GNU General Public License
!     along with this program.  If not, see <https://www.gnu.org/licenses/>.
!
!
!     SUBROUTINES IN THIS FILE COMPUTE EQUILIBRIUM HOPFION PROFILE AT
!     A PARTICULAR POINT ON THE PHASE DIAGRAM.
module profile
  use debug

  public :: SOLVE_EULER, ITERATE_MS

contains
! Iteratively searches for the hopfion profile with full account for
! magnetostatic interaction.
!
! If NFPTS=0 calls SOLVE_EULER to solve for an initial hopfion profile
! without the integral term (magnetostatics). If mu=0 this profile is
! returned to the caller, otherwise organizes iterations to find the
! equilibrium hopfion profile satisfying the full Euler equation with
! the integral term included.
!
! The parameter INFO specifies the level of the debug output sent to stderr:
!     INFO=0  --   no output
!     INFO>1  --   more output (currently the level is the same for all INFO>1)
!
! On output the value of NFPTS=0 means that iterations did not converge
! to the solution.
!
subroutine ITERATE_MS(HTYPE, g, h, q, nu, mu,  NFPTSMAX, NFPTS, FPTS, INFO)
  implicit none
  integer HTYPE, NFPTSMAX, NFPTS, INFO
  double precision g, h, q, nu, mu, FPTS(NFPTSMAX,3)
  integer, parameter :: LE=6          ! stderr logical unit

  double precision nuLAST

  integer, parameter :: MAXITER=100
  double precision, parameter :: EPSITER=1.0D-6
  integer ITER
  CALL ASSERT(HTYPE.ge.1.and.HTYPE.le.2)
  CALL ASSERT(g.gt.0.0D0)
  CALL ASSERT(NFPTS.le.NFPTSMAX)

  if (mu.eq.0.0D0) then
     call SOLVE_EULER(HTYPE,g,h,q,nu,mu,NFPTSMAX, NFPTS, FPTS)
     return
  end if

  if (NFPTS.LT.2) then
     call SOLVE_EULER(HTYPE,g,h,q,nu,0.0D0,NFPTSMAX, NFPTS, FPTS)
     if (NFPTS.eq.0) then
        if (INFO.gt.0) write (LE,'(A)') &
             "Failed to obtain initial (no MS) profile."
        return
     end if
     if (INFO.gt.0) write (LE,'(A,G18.10)') &
          "Initial (no MS) solution yields nu=", nu
  end if

  do ITER=1,MAXITER
     nuLAST=nu
     call SOLVE_EULER(HTYPE,g,h,q,nu,mu,NFPTSMAX, NFPTS, FPTS)
     if (NFPTS.eq.0) then
        if (INFO.gt.0) write (LE,'(A)') 'Euler equation solution failed.'
        return
     end if
     if (INFO.gt.0) write (LE,'(A,1X,I0,1X,A,1X,I0,1X,A,G18.10)') &
          "Iteration", ITER, "of", MAXITER, ": nu =", nu
     if (DABS(nu-nuLAST).le.EPSITER) then
        if (INFO.gt.0) write (LE,'(A,1X,I0,A)') &
             "Converged in", ITER, " iterations."
        return
     end if
  end do
  if (INFO.gt.0) write (LE,'(A,I0,A)') &
       "Failed to converge in", MAXITER, " iterations."
  NFPTS=0
end subroutine ITERATE_MS


! Computes the equilibrium hopfion profile in a stray field, generated by
! a hopfion with the specified "old" profile via solving the Euler equation.
!
! Parameters:
! IN:
!     HTYPE    - hopfion type: 1 or 2
!     g        - aspect ratio gamma (g=1 corresponds to sphere)
!     h        - the external field
!     q        - the anisotropy quality factor
!     mu       - the magnetostatic interaction strength mu=1/lambda
!     NFPTSMAX - dimension of FPTS(NPTSMAX,3) array (must be sufficient
!                to store the resulting profile points)
! IN/OUT:
!     nu     - the hopfion size, initial approximation on input, final
!              equilibrium size on output
!     NFPTS  - ON INPUT: if mu=0, NPTS must be 0, indicating that
!              magnetostatics is ignored; otherwise it is the number
!              of points in the "old" profile, which serves as a basis
!              for demagnetizing field calculation in an iterative procedure.
!              ON OUTPUT: the number of points in the resulting equilibrium
!              profile or 0 if the equaton can not be solved.
!     FPTS   - ON INPUT: if mu<>0, must contain an "old" hopfion profile for
!              demagnetizing field calculation.
!              ON OUTPUT: the resulting equilibrium hopfion profile.
!
subroutine SOLVE_EULER(HTYPE, g, h, q, nu, mu,  NFPTSMAX, NFPTS, FPTS)
  use energy
  implicit none
  integer, intent(IN) :: HTYPE, NFPTSMAX
  integer, intent(INOUT) ::  NFPTS
  double precision g, h, q, nu, mu, FPTS(NFPTSMAX,3)

! copy of the initial hofion profile
  integer NFPTSOLD
  double precision FPTSOLD(NFPTSMAX,3)

! parameters to the MUSN call
  integer, parameter :: N = 3
  double precision A, B, ER(5), AMP
  integer NRTI
  integer, parameter :: ITLIM = 30
  double precision TI(NFPTSMAX), Y(N,NFPTSMAX), QQ(N,N,NFPTSMAX)
  integer, parameter :: NUDIM = 6 ! N*(N+1)/2
  double precision U(NUDIM,NFPTSMAX), PHIREC(NUDIM,NFPTSMAX)
  double precision D(N,NFPTSMAX)
  integer KPART, LW, LIW, LWG
  double precision W(7*N + 3*N*NFPTSMAX + 4*N*N  )
  integer IW(3*N + NFPTSMAX)
  double precision WGR(NFPTSMAX*6)
  integer IERROR

  integer I
  double precision left,fl,fpl
  double precision NUSUM

  CALL ASSERT(HTYPE.ge.1.and.HTYPE.le.2)
  CALL ASSERT(g.gt.0.0D0)
!  CALL ASSERT(.not.(mu.eq.0.0D0.and.NFPTS.ne.0))
  CALL ASSERT(.not.(mu.gt.0.0D0.and.NFPTS.lt.2))
  CALL ASSERT(NFPTS.le.NFPTSMAX)

  ! copy the old profile
  NFPTSOLD=NFPTS
  do I=1,NFPTSOLD
     FPTSOLD(I,1)=FPTS(I,1)
     FPTSOLD(I,2)=FPTS(I,2)
     FPTSOLD(I,3)=FPTS(I,3)
  end do

  left=0.001
  ! determine the initial conditions from Taylor expansion
  call EulerTaylor(HTYPE, g, left, nu, h, q, mu, &
       NFPTSMAX, NFPTSOLD, FPTSOLD, fl, fpl)

  A      = left
  B      = 1.0D0
!  ER(1)  = 1.0D-6
!  ER(2)  = 1.0D-2
  ER(1)  = 1.0D-6
  ER(2)  = 1.0D-6
  ER(3)  = 1.1D-15
  NRTI   = 120
  AMP    = 0.80D0
  LW     = size(W)
  LIW    = size(IW)
  LWG    = size(WGR)
  IERROR = 0     ! set to 1 for making MUSL print diagnostics
  call MUSN(EQUATIONS, INITIAL_APPROX, BOUNDARY, N, &
       A, B, ER, TI, NFPTSMAX, NRTI, AMP, ITLIM, &
       Y, QQ, U, NUDIM, D, &
       PHIREC, KPART, W, LW, IW, LIW, WGR, LWG, IERROR)
  if (IERROR.eq.0) then
     CALL ASSERT(NRTI.lt.NFPTSMAX)
     FPTS(1,1)=0.0D0
     FPTS(1,2)=0.0D0
     FPTS(1,3)=0.0D0
     NUSUM=0.0D0
     do I=1,NRTI
        FPTS(1+I,1)=TI(I)
        FPTS(1+I,2)=Y(2,I)
        FPTS(1+I,3)=Y(1,I)
        NUSUM=NUSUM+Y(3,I)
     end do
     NFPTS=NRTI+1
     nu=NUSUM/NRTI
  else
     call xerror("MUSN RETURNED IERROR",IERROR,0)
     NFPTS=0
  end if
contains
  subroutine EQUATIONS(r,Y,F)
    implicit none
    double precision r, Y(3),F(3)
    F(1) = EulerFPP(HTYPE, g, r, Y(2), Y(1), Y(3), h, q, &
         mu, NFPTSMAX, NFPTSOLD, FPTSOLD)
    F(2) = Y(1)
    F(3) = 0.0D0
  end subroutine EQUATIONS
  subroutine BOUNDARY(N,XA,XB,FG,DGA,DGB)
    implicit none
    integer N
    double precision XA(N),XB(N),FG(N),DGA(N,N),DGB(N,N)

    CALL ASSERT(N.eq.3)
    FG(1) = XA(1) - fpl
    FG(2) = XA(2) - fl
    FG(3) = XB(2) - 1.D0

    DGA=0.0D0
    DGB=0.0D0

    DGA(1,1) = 1.D0
    DGA(2,2) = 1.D0
    DGB(3,2) = 1.D0
    return
  end subroutine BOUNDARY
  subroutine INITIAL_APPROX(T,X)
    implicit none
    double precision, intent(IN) :: T
    double precision, intent(OUT) :: X(3)
    double precision, parameter :: pi = 3.1415926535897932384626433832795d0
    logical SKIP
    integer IERR
    if (NFPTS.GE.2) then
       SKIP=.false.
       call DPCHFD(NFPTS, FPTS(1,1), FPTS(1,2), FPTS(1,3), 1, SKIP, &
            1, T, X(2), X(1), IERR)
       CALL ASSERT(IERR.EQ.0)
       X(3) = nu
    else
       if (HTYPE.EQ.1) then
          X(1) = 2.D0*T
          X(2) = T**2
       else
          ! type 2 hopfions require a more elaborate initial approximation
          X(1) = (16.0D0*(2.0D0*T + (7.0D0*T*Cos(2.0D0*pi*T) + &
               pi*(1.0D0 + 7.0D0*T**2)*Sin(2.0D0*pi*T))/ &
               (1.0D0 + 7.0D0*T**2)**2))/23.0D0
          X(2) = (16.0D0*(0.5D0 + T**2 - Cos(2.0D0*pi*T)/ &
               (2.0D0 + 14.0D0*T**2)))/23.0D0
       end if
       X(3) = nu
    end if
  end subroutine INITIAL_APPROX
end subroutine SOLVE_EULER
end module profile
